#include "asm/stx7105reg.h"
#include "../../cpu/sh/init_ram.S"

/*
 * This is derived from STMicroelectronics gnu toolchain example:
 *   sh-superh-elf/examples/os21/romdynamic/memory_mb680.S
 */

/*
 * The poke table is a series of long words, in the format
 *
 *	opcode, address, operand, ...
 *
 * An opcode of 0 marks the table end
 */

/*
 * For compatibility with old poke table code, we define some of the
 * new names, to map onto the old names. Ultimately, the old poke table
 * code will be updated to the "new order", and we can just delete
 * the following mappings.
 */
#define POKE8(A, VAL)				POKE_CHAR(A, VAL)
#define POKE16(A, VAL)				POKE_SHORT(A, VAL)
#define POKE32(A, VAL)				POKE_LONG(A, VAL)
#define OR32(A, VAL)				OR_LONG(A, VAL)
#define UPDATE32(A, AND, OR)			UPDATE_LONG(A, AND, OR)
#define POKE_UPDATE32(A1, A2, AND, SHIFT, OR)	POKE_UPDATE_LONG(A1, A2, AND, SHIFT, OR)
#define WHILE_NE32(A, AND, VAL)			WHILE_NE(A, AND, VAL)
#define DELAY(VAL)				/* do nothing */

.balign 32


__memory_setup_table:

	/* ----- STx7105 Clocks ----- */

	/* Set source clocks to OSC */
	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0x00000000)
	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x00000000)

	/* Wait for CLOCKGENA PLL0 to stop ... */
	WHILE_NE32(STX7105_CLOCKGENA_PLL0_ENABLE_FB, 0xFFFFFFFF, 0x00000000)

	/* Wait for CLOCKGENA PLL1 to stop ... */
	WHILE_NE32(STX7105_CLOCKGENA_PLL1_ENABLE_FB, 0xFFFFFFFF, 0x00000000)

	/*  Clockgen A PLL0 setup */

	/* Set CLOCKGENA PLL0 into BYPASS... */
	OR32(STX7105_CLOCKGENA_PLL0_CFG, 0x00100000)

	/* Power down CLOCKGENA PLL0... */
	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000001)

	/* Configure CLOCKGENA PLL0LS to 450MHz (PLL0HS to 900MHz): mdiv = 0x01, ndiv = 0x0f */
	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xfff80000, (0xf << 8) | (0x01 & 0x7))

	/* Enable CLOCKGENA PLL0... */
	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffe, 0)

	/* Wait for CLOCKGENA PLL0 to lock... */
	WHILE_NE32(STX7105_CLOCKGENA_PLL0_CFG, 0x80000000, 0x80000000)

	/* Clear CLOCKGENA PLL0 from BYPASS... */
	UPDATE32(STX7105_CLOCKGENA_PLL0_CFG, 0xffefffff, 0)

	/*  Clockgen A PLL1 setup */

	/* Set CLOCKGENA PLL1 into BYPASS... */
	OR32(STX7105_CLOCKGENA_PLL1_CFG, 0x00100000)

	/* Power down CLOCKGENA PLL1... */
	OR32(STX7105_CLOCKGENA_POWER_CFG, 0x00000002)

	/* Configure CLOCKGENA PLL1 to 800MHz: mdiv = 0x03, ndiv = 0x28, pdiv = 0x0 */
	/* UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (0 << 16) | (0x28 << 8) | (0x03)) */
	/* Configure CLOCKGENA PLL1 to 400MHz: mdiv = 0x09, ndiv = 0x78, pdiv = 0x1 */
	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xfff80000, (1 << 16) | (0x78 << 8) | (0x09))

	/* Enable CLOCKGENA PLL1... */
	UPDATE32(STX7105_CLOCKGENA_POWER_CFG, 0xfffffffd, 0)

	/* Wait for CLOCKGENA PLL1 to lock... */
	WHILE_NE32(STX7105_CLOCKGENA_PLL1_CFG, 0x80000000, 0x80000000)

	/* Clear CLOCKGENA PLL1 from BYPASS... */
	UPDATE32(STX7105_CLOCKGENA_PLL1_CFG, 0xffefffff, 0)


	/*  Clockgen A divider setup */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV0_CFG, 0x00000001)    /* STNOC=200 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV1_CFG, 0x00000000)    /* FDMA0=400 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV2_CFG, 0x00000000)    /* FDMA1=400 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV3_CFG, 0x00000103)    /* Not used */
	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV4_CFG, 0x00010100)  /* ST40_ICK=450 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV5_CFG, 0x00000103)    /* IC_IF_100=100  - for Comms */
	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV6_CFG, 0x00010100)  /* LX_DMU_CPU=450 */
	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV7_CFG, 0x00010100)  /* LX_AUD_CPU=450 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV8_CFG, 0x00000001)    /* IC_BDISP_200=200 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV9_CFG, 0x00000001)    /* IC_DISP_200=200 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV10_CFG, 0x00000001)   /* IC_TS_200=200  - for Crypto */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV11_CFG, 0x00000001)   /* DISP_PIPE_200=200 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV12_CFG, 0x00000001)   /* BLIT_PROC/IC_DELTA_200=266 */
	POKE32(STX7105_CLOCKGENA_PLL0LS_DIV13_CFG, 0x00000811) /* ETH_PHY=25 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV14_CFG, 0x0000050B)   /* PCI=33.3 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV15_CFG, 0x00000103)   /* EMI_MASTER=100 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV16_CFG, 0x00000001)   /* IC_COMPO_200=200 */
	POKE32(STX7105_CLOCKGENA_PLL1_DIV17_CFG, 0x00000001)   /* IC_IF_200=200 */

	/* Route clocks to ... */
	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG, 0xA6AA59AA)
	POKE32(STX7105_CLOCKGENA_CLKOPSRC_SWITCH_CFG2, 0x0000000A)

	/* SPI.CLOCK_DIV: divide emi_master_clk by 4 for spi boot clock */
	POKE32(0xfe702010, 0x00000004)

	/* ClockGen B for Audio */
	/*  No setup            */


	/* ClockGen D for LMI */

	/* Power down PLL... */
	OR32(STX7105_SYSCONF_SYS_CFG11, 0x00001000)

	/* Configure PLL... */
	/* Set LMI clock to 800MHz */
	/* UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x50 << 1)) */
	/* Cut 1.0 restriction -> Set LMI clock to 400MHz */
	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xfffff001, (0x03 << 9) | (0x28 << 1))

	/* Enable CLOCKGENA PLL1... */
	UPDATE32(STX7105_SYSCONF_SYS_CFG11, 0xffffefff, 0)

	/* Wait for CLOCKGENA PLL1 to lock... (polarity inverted on lock bit) */
	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, 0x00000001, 0)


	/* ----- STx7105 SysConf ----- */

	/* PLI_CLOCK_ENABLE set to 0 */
	/* OR32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2))	- Steve Punter misinterpretted? */
	UPDATE32(STX7105_SYSCONF_SYS_CFG04, ~(1 << 2), 0)

	/* LMI sub-sys & pl exit from reset */
	OR32(STX7105_SYSCONF_SYS_CFG11, (0x00000001 | (1 << 14) | 1 << 27))

	/* Delay ~ 200 microseconds (assume 400MHz CPU clock) */
	DELAY(200 * 400)

	/* PLI_CLOCK_ENABLE set to 1 */
	OR32(STX7105_SYSCONF_SYS_CFG04, (1 << 2))

	/* Check both DLL on LMI0 are locked */
	WHILE_NE32(STX7105_SYSCONF_SYS_STA03, (1 << 10) | (1 << 20), (1 << 10) | (1 << 20))

	/* Adjust proga, progb, zoutproga, and receiver mode for LMI0 */
	POKE32(STX7105_SYSCONF_SYS_CFG12, (0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10)))

	/* Enable AutoPrecharge */
	POKE32(STX7105_SYSCONF_SYS_CFG38, 0x002FFE0C)

	/* Force DLL1 and DLL2 commands of LMI0 */
	/* POKE32(STX7105_SYSCONF_SYS_CFG13, 0x00000000) */
	/* POKE32(STX7105_SYSCONF_SYS_CFG14, 0x00000000) */

	/* LMI Padlogic Control */
	POKE32(STX7105_SYSCONF_SYS_CFG55, 0x03fc2384)

	/* Include DUMMY PCB track */
	OR32(STX7105_SYSCONF_SYS_CFG55, (1 << 6))

	/* TO BE UPDATED FOR 7105/MB680 */
	/* sysconf.SYSCONF_CFG42.poke(sysconf.SYSCONF_CFG42.peek() | (0 << 18) | (0 << 9) | (0 << 0) ) */
	UPDATE32(STX7105_SYSCONF_SYS_CFG42, 0xfffbfdfe, 0)
	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0) ) */
	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffffffe, 0)

	/* Coarse settings (-T/4) */
	OR32(STX7105_SYSCONF_SYS_CFG42, (5 << 27))
	OR32(STX7105_SYSCONF_SYS_CFG13, (1 << 22))

	/* DQS Valid Window */
	/* sysconf.SYSCONF_CFG43.poke(sysconf.SYSCONF_CFG43.peek() | (0 << 18)) */
	UPDATE32(STX7105_SYSCONF_SYS_CFG43, 0xfffbffff, 0)

	/* DQS270_DEL offsets */
	/* sysconf.SYSCONF_CFG51.poke(sysconf.SYSCONF_CFG51.peek() | (0 << 16) | (0 << 0)) */
	UPDATE32(STX7105_SYSCONF_SYS_CFG51, 0xfffefffe, 0)
	/* sysconf.SYSCONF_CFG52.poke(sysconf.SYSCONF_CFG52.peek() | (0 << 16) | (0 << 0)) */
	UPDATE32(STX7105_SYSCONF_SYS_CFG52, 0xfffefffe, 0)


	/* ----- STx7105 EMI configuration ----- */

	POKE32(ST40_EMI_BANK_ENABLE, 0x00000005)

	/* NOTE: bits [0,5] define bottom address bits [22,27] of bank */
	POKE32(ST40_EMI_BANK0_BASEADDRESS, 0x00000000)
	POKE32(ST40_EMI_BANK1_BASEADDRESS, 0x00000010)
	POKE32(ST40_EMI_BANK2_BASEADDRESS, 0x00000012)
	POKE32(ST40_EMI_BANK3_BASEADDRESS, 0x00000014)
	POKE32(ST40_EMI_BANK4_BASEADDRESS, 0x0000001c)

	/* Bank 0 - 32MiB: NOR, NAND & Serial Flash at address 0x00000000 -> 0x03ffffff */
	POKE32(ST40_EMI_BANK0_EMICONFIGDATA0, 0x001016d1)
	POKE32(ST40_EMI_BANK0_EMICONFIGDATA1, 0x9d200000)
	POKE32(ST40_EMI_BANK0_EMICONFIGDATA2, 0x9d220000)
	POKE32(ST40_EMI_BANK0_EMICONFIGDATA3, 0x00000000)

	/* Bank 1 - 8MiB at address 0x04000000 -> 0x047fffff */
	POKE32(ST40_EMI_BANK1_EMICONFIGDATA0, 0x002016d1)
	POKE32(ST40_EMI_BANK1_EMICONFIGDATA1, 0x9d222200)
	POKE32(ST40_EMI_BANK1_EMICONFIGDATA2, 0x9d220044)
	POKE32(ST40_EMI_BANK1_EMICONFIGDATA3, 0x00000000)

	/* Bank 2 - 8MiB at address 0x04800000 -> 0x04FFFFFF */
	POKE32(ST40_EMI_BANK2_EMICONFIGDATA0, 0x002046f9)
	POKE32(ST40_EMI_BANK2_EMICONFIGDATA1, 0xa5a00000)
	POKE32(ST40_EMI_BANK2_EMICONFIGDATA2, 0xa5a20000)
	POKE32(ST40_EMI_BANK2_EMICONFIGDATA3, 0x00000000)

	/* Bank 3 - 32MiB at address 0x05000000 -> 0x06FFFFFF */
	POKE32(ST40_EMI_BANK3_EMICONFIGDATA0, 0x002016d1)
	POKE32(ST40_EMI_BANK3_EMICONFIGDATA1, 0x9d222200)
	POKE32(ST40_EMI_BANK3_EMICONFIGDATA2, 0x9d220044)
	POKE32(ST40_EMI_BANK3_EMICONFIGDATA3, 0x00000000)

	/* Bank 4 - 16MiB EPLD Registers at address 0x07000000 -> 0x07FFFFFF */
	POKE32(ST40_EMI_BANK4_EMICONFIGDATA0, 0x002016d1)
	POKE32(ST40_EMI_BANK4_EMICONFIGDATA1, 0x9d222200)
	POKE32(ST40_EMI_BANK4_EMICONFIGDATA2, 0x9d220044)
	POKE32(ST40_EMI_BANK4_EMICONFIGDATA3, 0x00000000)

	/* Program other EMI registers */
	POKE32(ST40_EMI_GENCFG, 0x00000010)


	/* ----- STx7105 LMI0 configuration ----- */

	/* Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E

	   SDRAM Mode Register
	   Refresh Interval:  NOTE: Using Lmi=200 (LMI2X=400).
	 # 300 Mhz --->  T=3.4ns => MIM[28:16]=2038=0x7F6 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
	 # 330 Mhz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
	 # 360 Mhz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
	 # 400 Mhz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
	 */
	POKE32(ST40_LMI_MIM_0(), 0x07F6017b)

	/* set bandwidth limiter */
	POKE32(ST40_LMI_MIM_1(), 0xffff0000)

	/* SDRAM Timing Register */
	POKE32(ST40_LMI_STR_0(), 0xcd2db41b)
	POKE32(ST40_LMI_STR_1(), 0x00202ed6)

	/* SDRAM Row Attribute 0 */
	/* lmi base address 0x0C000000 +
	    256 MiB   0x10000000
	              ----------
	              0x1C000000
	   Size: 13x10, 8 banks
	 */
	POKE32(ST40_LMI_SDRA0_0(), 0x1c001a20)

	/* SDRAM Row Attribute 1 */
	/* lmi base address 0x0C000000 +
	    256 MiB   0x10000000
	              ----------
	              0x1C000000
	   Size: 13x10, 8 banks
	 */
	POKE32(ST40_LMI_SDRA1_0(), 0x1c001a20)

	/* SDRAM Control Register */
	/* Delay ~ 200 milliseconds (assume 400MHz CPU clock) */
	DELAY(200000 * 400)
	/* Enable clock with NOP command */
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020023)
	/* Wait NOP command for 400 nsec */
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)

	/* Precharge all */
	POKE32(ST40_LMI_SCR_0(), 0x00020022)
	/* Wait NOP command for 400 nsec */
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)

	/* Issue EMRS2 */
	POKE32(ST40_LMI_SDMR0(), 0x00010000)

	/* Issue EMRS3 */
	POKE32(ST40_LMI_SDMR0(), 0x00018000)

	/* Issue EMRS1 to enable DLL */
	POKE32(ST40_LMI_SDMR0(), 0x00008004)

	/* Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequential, Burst length 8 */
	POKE32(ST40_LMI_SDMR0(), 0x00000b53)

	/* Wait NOP command for 400 nsec */
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)

	/* Precharge all */
	POKE32(ST40_LMI_SCR_0(), 0x00020022)

	/* 2 CBR (auto refresh) */
	POKE32(ST40_LMI_SCR_0(), 0x00020024)
	POKE32(ST40_LMI_SCR_0(), 0x00020024)

	/* Issue MRS with CAS 5, Write recovery 5, Sequential, Burst length 8 */
	POKE32(ST40_LMI_SDMR0(), 0x00000a53)

	/* Issue EMRS1 for OCD calibration default */
	/* lmi.LMI_SDMR0_0.poke(0x000007c4) */

	/* Issue EMRS1 for OCD calibration exit */
	/* lmi.LMI_SDMR0_0.poke(0x00000444) */

	/* Enable auto refresh */
	OR32(ST40_LMI_MIM_0(), (1 << 9))

	/* DQS recovery mechanism (bit 5) */
	/* OR32(ST40_LMI_MIM_0(), (1 << 5)) - Steve Punter misinterpretted? */
	UPDATE32(ST40_LMI_MIM_0(), ~(1 << 5), 0)
	/* NO DQS recovery */
	/* UPDATE32(ST40_LMI_MIM_0(), 0xffffffdf, 0) */

	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)
	POKE32(ST40_LMI_SCR_0(), 0x00020021)

	POKE32(ST40_LMI_GCC_0(), 0x00000000)

#ifdef CONFIG_SH_SE_MODE
	/*
	 * Note that we also manually need to move the LMI base addresses to
	 * their 32-bit SE mode locations as defined in the datasheet and change the
	 * 'upper bound addresses' (in row attribute registers) for the LMIs.
	 */
	UPDATE32(STX7105_SYSCONF_SYS_CFG38, 0xFFFFFF00, 0x00000040)
	/* Change LMI upper bound addresses
	 # Upper LMI addr=0x40000000 + 256MiB=0x50000000
	 */
	UPDATE32(ST40_LMI_SDRA0_0(), 0x001FFFFF, 0x50000000)
	UPDATE32(ST40_LMI_SDRA1_0(), 0x001FFFFF, 0x50000000)
#endif	/* CONFIG_SH_SE_MODE */

	END_MARKER

__memory_setup_table_end:

	.end
