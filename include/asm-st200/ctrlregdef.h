/*
 * include/asm-st200/ctrlregdef.h
 *
 * Copyright (C) 2002 STMicroelectronics Limited
 *	Author: Stuart Menefy <stuart.menefy@st.com>
 *
 * Control register defintions for generic ST200
 */

#ifndef _ASM_ST200_CTRLREGDEFS_H
#define _ASM_ST200_CTRLREGDEFS_H

#include "ctrlregdef-230.h"

#define CTRL_REG_BASE 0xffff0000

#define CTRL_ADDR(offset) (CTRL_REG_BASE+(offset))

/* Saved Program Counter, written by hardware on exception. */
#define SAVED_PC	CTRL_ADDR(0xffe8)

/* Saved PSW, written by hardware on exception. */
#define SAVED_PSW	CTRL_ADDR(0xfff0)

/* The Program Status Word. */
#define PSW		CTRL_ADDR(0xfff8)

/* Exception handler defines */

/* The address of the exception handler code. */
#define HANDLER_PC CTRL_ADDR(0xffe0)

/* A one hot vector of trap (exception/interrupt) types
   indicating the cause of the last trap. Written by the hardware on a trap. */
#define EXCAUSE CTRL_ADDR(0xffd8)

/* This will be the data effective address in the case of
    either a DPU, CREG, DBREAK, or MISALIGNED_TRAP exception.
    For other exception types this register will be zero. */
#define EXADDRESS CTRL_ADDR(0xffd0)

#define SCRATCH1 CTRL_ADDR(0xffa8)
#define SCRATCH2 CTRL_ADDR(0xffa0)
#define SCRATCH3 CTRL_ADDR(0xff98)
#define SCRATCH4 CTRL_ADDR(0xff90)

/* Performance register defintions */

#define PM_EVENT_DHIT		0	/* The number of load and stores that hit the cache. This includes uncached accesses that hit the cache. */
#define PM_EVENT_DMISS		1	/* The number of load and stores that miss the cache. This includes stores that miss the cache and are send to the write buffer. Uncached accesses are not included in this count. */
#define PM_EVENT_DMISSCYCLES	2	/* The number of cycles the core is stalled due to the data cache being busy. */
#define PM_EVENT_PFTISSUED	3	/* The number of prefetches */
#define PM_EVENT_PFTHITS	4	/* The number of cached loads that hit the prefetch buffer. */
#define PM_EVENT_WBHITS		5	/* The number of cached writes that hit the write buffer. */
#define PM_EVENT_IHIT		6	/* The number of accesses the instruction buffer made that hit the instruction cache. */
#define PM_EVENT_IMISS		7	/* The number of accesses the instruction buffer made that missed the instruction cache. */
#define PM_EVENT_IMISSCYCLES	8	/* The number of cycles the instruction cache was stalled for. */
#define PM_EVENT_IBUFINVALID	9	/* Duration where IBuffer is not able to issue bundles to the pipeline. */
#define PM_EVENT_BUNDLES	10	/* Bundles executed. */
#define PM_EVENT_LDST		11	/* Load/Store instructions executed. */
#define PM_EVENT_TAKENBR	12	/* Number of taken branches (br and brf), rfis,goto sandcall s.  */
#define PM_EVENT_NOTTAKENBR	13	/* Number of not taken branches (br and brf). */
#define PM_EVENT_EXCEPTIONS	14	/* Number of exceptions and Debug interrupts. */
#define PM_EVENT_INTERRUPTS	15	/* Number of interrupts. */
#define PM_EVENT_BUSREADS	16	/* Number of architectural read transactions issued to the bus. This is the number of uncached reads, I & D cache refills and prefetches issued to the bus. */
#define PM_EVENT_BUSWRITES	17	/* Number of architectural write transactions issued to the bus. This is the number of write buffer lines evicted and the number of uncached writes issued to the bus. */
#define PM_EVENT_OPERATIONS	18	/* Number of completed operations. Includes nops in the instruction stream but not those added dynamically. This counter excludes long immediates. */
#define PM_EVENT_WBMISSES	19	/* Number of cached writes that missed the cache and misses the write buffer. This excludes cache line evictions. */
#define PM_EVENT_NOPBUNDLES	20	/* Number of completed bundles that were empty or contained only nops. This includes nop bundles generated by instruction buffer stalls and interlocking stalls. It excludes pipeline stalls due to load/stores and control register/sdi accesses. */

#define PM_CR		CTRL_ADDR(0xf800)	/* Performance monitoring control. */
#define PM_CNT0		CTRL_ADDR(0xf808)	/* Performance monitor counter 0 value. */
#define PM_CNT1		CTRL_ADDR(0xf810)	/* Performance monitor counter 1 value. */
#define PM_CNT2		CTRL_ADDR(0xf818)	/* Performance monitor counter 2 value. */
#define PM_CNT3		CTRL_ADDR(0xf820)	/* Performance monitor counter 3 value. */
#define PM_PCLK		CTRL_ADDR(0xf828)	/* Performance monitor core cycle counter. */

#define PM_CR_ENB	0	/* When 1, counting is enabled. When 0 counting is disabled. */
#define PM_CR_RST	1	/* When a 1 is written all the counters (PM_CNT0-3 and PM_PCLK) are set to zero. If a 0 is written it is ignored. This field does not retain its value and so always reads as 0. */
#define PM_CR_EVENT0	12	/* 5-bit field specifying the event being monitored for this counter. */
#define PM_CR_EVENT1	17	/* 5-bit field specifying the event being monitored for this counter. */
#define PM_CR_EVENT2	22	/* 5-bit field specifying the event being monitored for this counter. */
#define PM_CR_EVENT3	27	/* 5-bit field specifying the event being monitored for this counter. */

/* Debug related registers */

#define DBREAK_LOWER	CTRL_ADDR(0xfe80)	/* Data breakpoint lower address. */
#define DBREAK_UPPER	CTRL_ADDR(0xfe78)	/* Data breakpoint upper address. */
#define DBREAK_CONTROL	CTRL_ADDR(0xfe70)	/* Data breakpoint control. */

#define IBREAK_LOWER	CTRL_ADDR(0xfdd0)	/* Instruction breakpoint lower address. */
#define IBREAK_UPPER	CTRL_ADDR(0xfdc8)	/* Instruction breakpoint upper address. */
#define IBREAK_CONTROL	CTRL_ADDR(0xfdc0)	/* Instruction breakpoint control. */

#define BREAK_CONTROL_BRK_IN_RANGE	(1<<0)	/* Break if address >= lower && address <=upper. */
#define BREAK_CONTROL_BRK_OUT_RANGE	(1<<1)	/* Break if address < lower || address > upper. */
#define BREAK_CONTROL_BRK_EITHER	(1<<2)	/* Break if address == lower || address == upper. */
#define BREAK_CONTROL_BRK_MASKED	(1<<3)	/* Break if address & upper == lower. */

#define SAVED_SAVED_PSW	CTRL_ADDR(0xffc0)	/* PSW saved by debug unit interrupt. */
#define SAVED_SAVED_PC	CTRL_ADDR(0xffb8)	/* PC saved by debug unit interrupt. */

#define PERIPHERAL_BASE	0x1f000000

#endif /* _ASM_ST200_CTRLREGDEFS_H */
